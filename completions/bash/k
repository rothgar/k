#!/usr/bin/env bash

# Source kubectl completion and rename all kubectl references to k
# This makes the standard kubectl completion work for the k command
source <(kubectl completion bash | sed 's/kubectl/k/g')

# Custom completion functions for k's special syntax (@cluster, +context, :namespace)

__k_kspace_parse_config() {
    local template k_out lead_char

    # Keep the leading character (+ or @) in completions
    case $1 in
    contexts )
        lead_char='+' ;;
    clusters )
        lead_char='@' ;;
    esac

    # Template to list contexts or clusters with the leading character
    template="{{ range .$1  }}$lead_char{{ .name }} {{ end }}"

    # ${cur##*,} removes everything up to and including the last comma
    # This allows completion of comma-separated values
    if k_out=$(k config view -o template --template="${template}" 2>/dev/null); then
        COMPREPLY=( $( compgen -W "${k_out[*]}" -- "${cur##*,}" ) )
        # Don't add space after completion so users can add :namespace
        compopt -o nospace
    fi
}

__k_kspace_parse_get() {
    local template
    template="${2:-"{{ range .items  }}{{ .metadata.name }} {{ end }}"}"
    local k_out

    # ${cur%%:*} removes everything after (and including) :
    # This gets the cluster/context part to query the right cluster
    if k_out=$(k ${cur%%:*} get -o template --template="${template}" "$1" 2>/dev/null); then
        # Remove the leading : for filtering with compgen
        cur=${cur#*:}
        # ${cur##*,} removes everything up to the last comma for multi-namespace completion
        COMPREPLY=( $( compgen -W "${k_out[*]}" -- "${cur##*,}") )
        # Don't add space after namespace in case user wants to add another comma
        compopt -o nospace
    fi
}

__k_kspace_parse_config_contexts() {
    __k_kspace_parse_config "contexts"
}

__k_kspace_parse_config_clusters() {
    __k_kspace_parse_config "clusters"
}

__k_kspace_get_resource_namespace() {
    __k_kspace_parse_get "namespace"
}

__k_handle_kspace() {
    local cur prefix

    # Use _get_comp_words_by_ref excluding : from COMP_WORDBREAKS
    # This is needed because _init_completion would split ":namespace" incorrectly
    _get_comp_words_by_ref -n : cur || return

    # Match patterns for k's special syntax
    case $cur in
    # Multiple namespaces: :ns1,ns2 or +context:ns1,ns2 or @cluster:ns1,ns2
    :*,* | *:*,* )
        # Remove leading colon to avoid duplication in prefix
        cur=${cur#:}
        # Everything before the last comma becomes the prefix
        prefix="${cur%,*},"
        __k_kspace_get_resource_namespace
        # Add the prefix back to each completion (excluding the : part)
        COMPREPLY=( "${COMPREPLY[@]/#/${prefix#*:}}" )
        ;;
    # Single namespace: :namespace
    :* )
        __k_kspace_get_resource_namespace
        ;;
    # Context or cluster with namespace: +context:ns or @cluster:ns
    *:* )
        [[ $cur == *,* ]] && prefix="${cur%,*},"
        __k_kspace_get_resource_namespace
        COMPREPLY=( "${COMPREPLY[@]/#/$prefix}" )
        ;;
    # Context only: +context
    +* )
        __k_kspace_parse_config_contexts
        ;;
    # Cluster only: @cluster
    @* )
        __k_kspace_parse_config_clusters
        ;;
    esac
}

# Override __k_handle_word to intercept k's special syntax before normal kubectl completion
# This is the key function that gets called for each word during completion
__k_handle_word() {
    # Check if the current word starts with our special characters
    for char in @ : +; do
        if [[ ${words[c]} = $char* ]]; then
            __k_handle_kspace
            return
        fi
    done

    # If not a kspace word, continue with normal kubectl completion
    if [[ $c -ge $cword ]]; then
        __k_handle_reply
        return
    fi
    __k_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"
    if [[ "${words[c]}" == -* ]]; then
        __k_handle_flag
    elif __k_contains_word "${words[c]}" "${commands[@]}"; then
        __k_handle_command
    elif [[ $c -eq 0 ]]; then
        __k_handle_command
    elif __k_contains_word "${words[c]}" "${command_aliases[@]}"; then
        # aliashash variable is an associative array which is only supported in bash > 3
        if [[ -z "${BASH_VERSION:-}" ]] || [[ "${BASH_VERSINFO[0]}" -gt 3 ]]; then
            words[c]=${aliashash[${words[c]}]}
            __k_handle_command
        else
            __k_handle_noun
        fi
    else
        __k_handle_noun
    fi
    __k_handle_word
}
